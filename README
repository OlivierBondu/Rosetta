################################################################################
Rosetta: A Higgs Effective Field Theory basis translator

Benjamin Fuks, Fabio Maltoni, Kentarou Mawatari, 
Ken Mimasu, Veronica Sanz, Francesco Riva 

Version 1.0, July 2015
################################################################################
Rosetta is a translation tool to aid in the Monte Carlo generation of events for
Higgs Effective Field Theory. The idea is to provide a simple way to map 
different parametrisations of the deviations of Higgs couplings from SM 
expectations to a single 'basis' of Wilson coefficients corresponding to 
operators up to dimension 6.

Given an SLHA style input parameter card in the users basis of choice, Rosetta 
has the capability to read in the parameters, calculate any dependent 
parameters, perform a number of consistency checks with respect to required and 
derived inputs and finally write out a new parameter card in the target basis. 
The SHLA output for the default target, MassBasis, can be used as input to the 
associated UFO model in a compatible event generator. 

The tool consists of a Python package containing implementations of Higgs 
Effective Theory bases and a command line tool 'translate' that performs the 
task of mapping a given basis to a target output basis. The core of the package 
is based on the contents of the LHC Higgs Cross Section Working Group (HXSWG) 
note (LHCHXSWG-INT-2015-001).

################################################################################
   Contents
################################################################################
1) Contact
2) Prerequisites
3) Usage
4) Input cards
5) The SLHA package
6) The basis class
7) Implementing your own basis
8) eHDECAY interface

################################################################################
1) Contact
################################################################################
Feel free to contact the authors with requests for features, bugs 
etc. through k.mimasu@sussex.ac.uk.

################################################################################
2) Prerequisites
################################################################################
Python 2.7 or above in the 2.X series (not python 3).

################################################################################
3) Package Contents
################################################################################
Rosetta/    # Python package containing implementation of the basis 
            # translation machinery.
            
    --> __init__.py         # Assumes all files in the top directory other than 
                            # itself are basis implementations and includes them
                            # in Rosetta's translation 'database'.
    
    --> config.txt          # file storing configuration variables
                                
    --> MassBasis.py        # Basis class for the  default target basis 
                            # for output parameter cards, corresponds to the 
                            # redundant set of operators defined in  
                            # HiggsBasis.py without imposing any dependency 
                            # conditions.
                            
    --> HiggsBasis.py       # Basis class corresponding to the Higgs Basis as 
                            # defined in the HXSWG draft. Using this basis as 
                            # input calculates the dependent coefficients.
                            
    --> WarsawBasis.py      # Basis class corresponding to the Warsaw Basis
                            # defined in arXiv:1008.4884 and the HXSWG draft.
    
    --> SILHBasis.py        # Basis class corresponding to the SILH Basis
                            # defined in e.g arXiv:1303.3876 and the HXSWG draft.
    
    --> TemplateBasis.py    # Template for a user-defined Basis class 
                            # implemented in the Rosetta package. Toy versions 
                            # of the calculate_dependent() and translation
                            # methods are implemented.
    internal/
        --> __init__.py     # Stores a number of useful dictionaries mapping PDG
                            # particle IDs and SLHA input numbers to names, 
                            # default values for SM inputs and particle masses
                            # etc.
        --> Basis.py        # Base basis class implementing internal methods 
                            # such as reading/writing param cards and checking 
                            # for required/calculated inputs. All basis classes 
                            # are derived from this one.
        --> SLHA.py         # Machinery for reading, manipulating and writing 
                            # SLHA style input cards. Implementation partly 
                            # inspired by pySLHA (A. Buckley, arXiv:1305.4194).
        --> eHDECAY.py      # Interface with eHDECAY program (arXiv:1403.3381)
        --> machinery.py    # Constructs translation paths between bases.
        --> matrices.py     # Higher level matrix objects inheriting from 
                            # structures in SLHA.py that can impose restrictions 
                            # on the matrix properties such as herimticity etc. 
                            # Also contains a number of matrix operations such 
                            # as multiplication and element-wise addition for 
                            # use in translation functions.
        --> settings.py     # Reader for config.txt
        --> decorators.py   # the @translation decorator used to identify 
                            # translation functions and their target basis in 
                            # basis implementations.
        --> query.py        # Yes/no query function borrowed from 
                            # http://code.activestate.com/recipes/577058/.

Cards/    # Sample MG5-style parameter cards to be used as input.

    HiggsBasis.dat       # Sample HiggsBasis input parameter card
    WarsawBasis.dat      # Sample WarsawBasis input parameter card
    SILHBasis.dat        # Sample SILHBasis input parameter card
    TemplateBasis.dat    # Sample TemplateBasis input parameter card

_diagonal and _universal versions of thee card are also included reflecting the 
simplified input formats one can use when employing the --flavour option of 
translate

    MassBasis.dat        # Sample MassBasis output parameter card, needn't 
                         # be used as input
    
translate   # Command line tool to perform basis translation based on the
            # implementations in Rosetta

################################################################################
3) Usage
################################################################################
The translate command line tool takes an SLHA-style param card (see sample 
cards provided in Cards/ directory) in a particular basis and outputs a new 
card in the specified basis (default is Mass Basis).  

Command line documentation:
    
    >> usage: translate [-h] [-o OUTPUT] [-t TARGETBASIS] [-w] [-e] PARAMCARD
    >> 
    >> Read in an SLHA format parameter card in a particular basis and write a 
    >> new card in another implemented basis.
    >> 
    >> positional arguments:
    >>   PARAMCARD             Input parameter card.
    >> 
    >> optional arguments:
    >>   -h, --help            show this help message and exit
    >>   -o OUTPUT, --output OUTPUT
    >>                         Output file name. Default: [PARAMCARD]_new
    >>   -t TARGETBASIS, --target TARGETBASIS
    >>                         Basis into which to translate (one of: silh, 
    >>                         higgs, mass, template, warsaw). Default: mass
    >>   -w, --overwrite       Overwrite any pre-existing output file.
    >>   -e, --ehdecay         Interface with eHDECAY for Higgs branching 
    >>                         fractions.
    >> -f FLAVOUR, --flavour FLAVOUR
                               Specify flavour structure ('general', 'diagonal',
                               'minimal'). Default : 'general'

Rosetta will read the SLHA card, look for the 0th element of block "basis", and 
see if any implemented basis classes have this unique identifier. If so, Rosetta 
will fill an instance of this class with the values of the parameters specified 
in the parameter card and perform certain consistency checks, making sure all 
required parameters are defined etc. Any dependent parameters are then 
calculated and the translation is performed between the input basis and the 
target basis (mass basis by default), provided the right translation path 
exists. An SLHA style parameter card wil then written out in the new basis. 
Rosetta can optionally interface with eHDECAY provided a translation path 
between the input basis and the SILH basis exists. The results of eHDECAY 
are also written to the SLHA card in the form of a decay block for the Higgs. 
See section 8 for more details on this.

Example basic usage:

To translate from the SILH basis to the Mass basis one could take 
Cards/SILHBasis.dat as a template input card and run:

./translate -o my_out.dat my_input.dat

To translate to the Warsaw basis instead, one should use the -t option and 
specify 'warsaw' as the target basis:
 
./translate -o my_out_warsaw.dat -t warsaw my_input.dat

Example usage with the flavour option:

The flavour option '-f' currently accepts the arguments 'general', 'diagonal' 
and 'minimal'. It tells Rosetta to assume a particular flavour structure in the 
input file. When a translation to a basis which is NOT the mass basis is 
specified via the '-t' option, the output file block structure also reflects 
this choice on the flavour structure. 

- 'general' : The default setting corresponding to the full flavour structure.
- 'diagonal': Keep only the diagonal terms in the flavour matrices i.e. the 
              11,22,33 entries.
- 'minimal' : Suppress all flavour indices. Coefficients are all flavour 
              diagonal and universal.

Thsi has been implemented in a simple way that relies on a particular naming 
convention for the flavoured coefficients. Namely, entries of a coefficient 
'XXX' should be appended to the name i.e. 'XXX11', 'XXX23' etc. If the 
coefficient is complex, the real and imaginary components should be labelled 
AFTER the flavour indices e.g.'XXX12Re', 'XXX12Im'. 
The function 'flavour_matrix' defined in Rosetta/internal/Basis.py is meant to 
help one generate flavour indices of a given coefficient according to the naming 
convention by specifying its properties such as 'hermitian' or 'symmetric' 
etc. It is used in the implementations of HiggsBasis, SILHBasis and WarsawBasis.

As an example, taking Cards/WarsawBasis_diagonal.dat as a template input, the 
command:

./translate -f diagonal -o my_out_diag.dat my_input_diagonal.dat

Will generate a Mass basis param card with only the diagonal flavour 
components non-zero. On the other hand,

./translate -t silh -f diagonal -o my_out_diag_silh.dat my_input_diagonal.dat

Will generate a SILH basis parameter card respecting the original flavour 
structure, i.e. that of Cards/SILHBasis_diagonal.dat.

In general, one should ensure that the block structure of the input card 
respects the flavour option specified, otherwise, Rosetta will crash.

Example usage with the eHDECAY option:

./translate -t silh -e -o my_out_ehdecay_silh.dat my_input.dat

This command will generate the same output as the basic usage example with the 
addition of an SLHA decay block for the Higgs with the results of the eHDECAY 
run. It will also save theeHDECAY input file fed to the program as 'ehdecay.in'.

################################################################################
4) Input cards
################################################################################
Rosetta is designed to read input cards in a format similar to the SUSY Les 
Houches Accord (SLHA) detailed in http://arxiv.org/abs/hep-ph/0311123. 
Sample cards can be found in the Cards/ directory. 

The SHLA reader looks for block structures in a case insensitive way i.e.

>> BLOCK MYBLOCK

Specifically it will search for blocks MASS, SMINPUTS and BASIS. The basis into 
which the card is read is taken from the 0 entry in the BASIS block. This name 
should match a basis declared in implemented.py (see next section).
Block elements should be named by placing a comment alongside each 
entry. The parameter name will be tken as the first non-whitespace characters 
following the '#' character.

The main difference between the input format of Rosetta and SLHA is that names 
of parameters are required for new physics parameter blocks. Parameters can 
then be referenced by name or number in the corresponding block or, 
alternatively, by name only from the SHLA.Card instance stored in as self.card 
in the basis instance.

>>BLOCK MYBLOCK
>>  0 3.14159E+00 # pi
>>  1 1.97327E-01 # hbarc_GeVfm
>>  Block sminputs 
>>      1   1.325070e+02       #    aEWM1  (white space doesn't matter)
ETC.

The block structure of the new physics couplings is basis dependent and should 
be declared in the `blocks` data member of the basis class. This should be a 
python dictionary with block names as keys and lists of parameter names as 
values. The ordering of the list determines the entry number of each parameter.
For example,

>> blocks = {'ONE':['A','B','C'], 'TWO':['D','E','F']}

will generate the following block structure:

>> block one
>>     0 0.0 # A
>>     1 0.0 # B
>>     2 0.0 # C
>>
>> block two
>>     0 0.0 # D
>>     1 0.0 # E
>>     2 0.0 # F

The reader reads all lines until the next occurrence of 'BLOCK' or 'DECAY', 
ignoring leading and trailing white space and all lines beginning with a '#' as 
well as lines that do not match the expected pattern detailed above. For blocks 
BLOCKIN and SMINPUTS, the reader stores special SLHA.Block instances as 
self.mass and self.inputs data member of the basis instace.

>> block mass 
>>     5 4.700000e+00 # MB 
>>     6 1.730000e+02 # MT 
>>    15 1.730000e+02 # MTAU
>>    23 9.118800e+01 # MZ 
>>    25 1.250000e+02 # MH 

Block basis should have one element corresponding to the "name" attribute of an 
existing basis implementation.

>> block BASIS
>> 0 MyBasis # name of basis

################################################################################
5) The SLHA package
################################################################################
Rosetta contains a basic SLHA card reader/writer that can parse and store the 
contents of an SLHA formatted input card. Individual blocks and decays are 
stored as SLHA.Block and SLHA.Decay instances which are subclasses of 
`OrderedDict`, meaning they can be indexed and iterated over in the same way.
 
    SLHA.Block is essentially a named OrderedDict storing index:value pairs 
    corresponding to the elements of an SLHA block. SLHA.Block has a "name" 
    attribute and forces keys to be of type `int` or to be castable via int().

    SLHA.Decay is an OrderedDict with a "PID" attribute for the particle whose 
    decay information it contains as well as a "total" attribute to store the 
    total width of the particle. Each entry key is a tuple if PIDs corresponding 
    to the decay products and the associated value is the branching fraction of 
    that particular channel. 
    
    SLHA.NamedBlock is a subclass of SHLA.Block with the additional feature that
    each block entry is associated to a name in accordance with the way Rosetta 
    can read the input card. Each value can then be accessed either by key or 
    by value.
    
    SLHA.Card is the object storing the various SLHA blocks and decays. Indexing 
    such an object with an integer will look for a Decay object associated to 
    that PID, while indexing with a string will look for a parameter with that 
    name in one of its NamedBlock instances. SLHA.Card objects possess two 
    OrderedDicts, "blocks" and "decays" storing the individual 
    SLHA.(Named)Block and SLHA.Decay instances. 

Each SLHA object can print itself out in the usual SLHA format, while the 
SLHA.Card object has a write() function to write itself to a file.
################################################################################
6) The basis class
################################################################################
Each implemented basis in Rosetta is a python class inheriting from the `Basis` 
class in Rosetta/internal/Basis.py. They are designed to be instantiated with 
an SLHA format parameter card using read_param_card(). The contents of the card 
are stored as an SLHA.Card object and the special blocks "mass" and "sminputs" 
are stored as SLHA.NamedBlock instances in self.mass and self.input 
respectively. Some of the key data members are:

self.name   
            - Unique basis identifier. This will be compared to the 0th element 
              of the block basis in the SLHA parameter card to ensure that 
              right basis class is being instantiated for a given input card.
              
self.card   
            - SLHA.Card instance containing SLHA.NamedBlock and SLHA.Decay 
              instances corresponding to those specified in the parameter card. 
              Object names taken to be the first non-whitespace characters 
              after a "#" character in a block or parameter definition are also 
              stored.
              
self.mass  
            - SLHA.NamedBlock instance for the "mass" block
            
self.inputs 
            - SLHA.NamedBlock instance for the "sminputs" block

self.name   - Unique basis identifier

self.required_inputs
            - A set of SLHA input IDs denoting those required to be defined in  
              the SLHA input card in order to perform implemented translations. 
              
self.required_masses
            - A set of PDG particle IDs denoting particles whose mass is 
              required to be defined in the SLHA input card in order to perform 
              implemented translations. 
              
self.independent
            - A list of coefficients deemed to be input parameters to the basis 
              implementation. 
              
self.blocks (optional but strongly recommended)
            - A dictionary of name:coefficients pairs where name is the SLHA 
              block name desired and coefficients is a list of coefficient 
              names associated to that block.

self.blocks, self.required_inputs and self.required_masses should be defined in 
accordance with block structure of the input SLHA parameter card, Blocks 
"sminput" and "mass" respectively (the Z ahd Higgs masses are also stored in 
self.inputs). Specifically, the block names specified as keys in self.blocks 
should match block names in the SLHA card as well as the names and indices of 
their elements (taken to be the order in which the appear in the list 
associated the the block in self.blocks). The blocks "mass" and "sminputs" of 
the SLHA card should minimally contain the entries specified in required_masses 
and required_inputs respectively. A number of checks related to these 
definitions are performed by check_param_data(), check_mass() and 
check_sminputs() on the data read in from the parameter card.

Basis and any of its subclasses are designed to work similarly to a 
dictionary in that parameter values can be referenced by name (duplicate 
names in different blocks are not handled properly so try to avoid them). 
A value can be referenced in various ways, see below example where the 
parameter named 'D' is stored as entry 3 in the block 'letters' written in 
'mycard.dat':
    
    >> instance = MyBasis(param_card='mycard.dat')
    >> instance['A'] = 0.5 # set value according to name in SLHA card
    >> instance.card['A'] = 0.5 # equivalent to the above
    >> instance.card.blocks['letters']['A'] = 0.5 # from block by name 
    >> instance.card.blocks['letters'][3] = 0.5 # from block by entry 

A number of other container methods are defined for easy of manipulation:

    >> print len(instance) # number of EFT coefficients
    >> for i in instance: # iterator methods also defined
    >>     print i
    >> for k, v in instance.items(): # name, value pairs
    >>     print k, v

write_param_card() writes the contents of the self.newcard into a new SLHA 
formatted file. Another useful method write_template_card() generates and empty 
parameter card according to the block definitions and required inputs of a 
given basis class.

################################################################################
7) Implementing your own basis
################################################################################
Implementing ones own basis involves creating a file inside the root directory 
of Rosetta, alongside HiggsBasis etc., containing a subclass of Basis. The 
only required data member to be defined is self.name. However, users will 
mostly likely want to define self.independent, self.required_inputs and 
self.required_masses as well as structure their basis into blocks using 
self.blocks (Rosetta will create one block named "newcoup" if self.blocks is 
not defined). An example is shown below where the required data members are 
defined outside the class construtor so as to instrinsically belong to all 
instances of the class. This code would be saved in Rosetta/MyBasis.py. It is 
essential that the file name match the class name.

    >> from internal import Basis
    >> class MyBasis(Basis.Basis):
    >>    name = 'mybasis'
    >>    independent = {'A','B','C','1','2','3'}
    >>    required_inputs = {1,2,4}   # a_{EW}^{-1}, Gf and MZ required
    >>    required_masses = {24,25,6} # Z, Higgs and top masses required
    >>    blocks = {'letters':['A','B','C','D']
    >>              'numbers':['1','2','3','4']} # Expected block structure

The list self.independent stores the basis parameters which should be read 
in from the SLHA card. Any other parameters declared in self.blocks are assumed 
to be set by the user in the calculate_dependent() method. The user can define 
calculate_dependent() to set any dependent parameters (those listed in in 
self.blocks but not in self.independent) and any number of additional 
functions, usually to translate the coefficients into a given basis which sets 
the SLHA.Card object, self.newcard. 

Rosetta differentiaties from general utility functions and translation 
functions using the "translation" decorator. Any function designed to take you 
to another existing basis implemenation should be decorated with the 
"translation" decorator with an argument corresponding to the name of the 
target basis. This name should match the unique name of an existing basis 
implementation also contained in the Rosetta root directory. Below would be 
example of a translation function from our example to the Warsaw Basis.

    >> @Basis.translation('warsaw') # identifies as translator to warsaw 
    >> def mytranslation(self, instance):
    >>     instance['cWW'] = 10.
    >>     instance['cpHl11'] = self['myparam']
    >>     return instance

The translating function must ONLY take an instance of the target class as its 
second argument alongside the default "self" argument for a class method. In 
this way, Rosetta can universally and automatically detect and use intended 
translation functions.

Any python module saved in the root directory of the Rosetta package is 
assumed to be a basis implementation. Furthermore, the class name of the 
basis implementation MUST be the same as the file name of the python 
module. In our example above, the class `MyBasis` would have to be saved in 
a file named MyBasis.py. This is to help Rosetta automatically identify the 
possible translation paths between bases. Any such class can then be used 
by the command line script "translate". For example, Rosetta should be able 
to figure out all possible multi-step translations.

The user is referred to Rosetta/TemplateBasis.py for a toy working example of a 
user defined basis.

################################################################################
8) eHDECAY interface
################################################################################
A useful program based on HDECAY (arXiv:hep-ph/9704448) for calculating the 
Higgs total width was developed in 2014 and is described in arXiv:1403.3381. 
The program takes as input a number of parameters in the SILH basis to calculate
the width and branching ratios to SM particles optionally including Electroweak 
corrections. In order to have this working correctly the user must modify 
Rosetta/config.txt, putting the absolute path to the base directory of a local 
eHDECAY installation. It goes without saying that there must exist a possible 
translation path between the input basis and the SILH basis. The 
internal/eHDECAY.py module then performs this translation, rescales the 
relevant parameters of the Rosetta SILH basis implementation to match the 
conventions of arXiv:1403.3381 and executes a run of eHDECAY. The results are 
stored and a copy of the input file "ehdecay.in" is saved locally. The results 
are then written to and SLHA decay block in the output card. The relevant 
input parameters are:

    SM inputs: # ALL masses must be nonzero for eHDECAY to give a finite result
    'MC', 'MB', 'MT', 'MMU', 'MTAU, # SM fermion masses
    'MH', 'MZ', 'MW', 'aEWM1' 'Gf', # EW input masses, (alpha_EW)^-1, G_Fermi
    'aSMZ'                          # alpha_S(MZ)

    SILH coefficients:
    'CHbar' , 'CTbar' , 'Ctaubar', 'Cmubar', 'Ctbar',
    'Cbbar' , 'Ccbar' , 'Csbar'  , 'CWbar' , 'CBbar',
    'CHWbar', 'CHBbar', 'Cgambar', 'Cgbar'

    eHDECAY option:
    'IELW' # Electroweak corrections switch (1:on, 0:off)

eHDECAY can potentially give negative branching fractions and even a negative 
total Higgs width for unreasonable choices of EFT parameters. A negative total 
width is currently not allowed while negative branching fractions are not 
handled and will be written to the parameter card.

################################################################################
Rosetta: A Higgs Effective Field Theory basis translator
################################################################################

