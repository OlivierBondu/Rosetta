################################################################################
Rosetta: A Higgs Effective Field Theory basis translator

Benjamin Fuks, Fabio Maltoni, Kentarou Mawatari, 
Ken Mimasu, Veronica Sanz, Francesco Riva 

Version 1, July 2015
################################################################################
Rosetta is a translation tool to aid in the Monte Carlo generation of events for
Higgs Effective Field Theory. The idea is to provide a simple way to map 
different parametrisations of the deviations of Higgs couplings from SM 
expectations to a single 'basis' of Wilson coefficients corresponding to 
operators up to dimension 6.

Given an SLHA style input parameter card in the users basis of choice, Rosetta 
has the capability to read in the parameters, calculate any dependent 
parameters, perform a number of consistency checks with respect to required and 
derived inputs and finally write out a new parameter card in the target basis. 
The SHLA output for the default target, MassBasis, can be used as input to the 
associated UFO model in a compatible event generator. 

The tool consists of a Python package containing implementations of 
Higgs Effective Theory bases and a command line tool 'translate' that performs 
the task of mapping a given basis to a target output basis. The core of the 
package is based on the contents of the LHCHiggs Cross Section Working Group 
(HXSWG) draft.

################################################################################
   Contents
################################################################################
1) Contact
2) Prerequisites
3) Usage
4) Input cards
5) The basis class
6) Implementing your own basis
7) eHDECAY interface

################################################################################
1) Contact
################################################################################
Feel free to contact the authors with requests for features, bugs 
etc. through k.mimasu@sussex.ac.uk.

################################################################################
2) Prerequisites
################################################################################
Python 2.7 or above

################################################################################
3) Package Contents
################################################################################
Rosetta/    # Python package containing implementation of the basis 
            # translation machinery.
            
    __init__.py     # Stores the location of the local eHDECAY installation
    internal/
        --> Basis.py        # Base basis class implementing internal methods 
                            # such as reading/writing param cards and checking 
                            # for required/calculated inputs. All basis classes 
                            # are derived from this one.
        --> SLHA.py         # Machinery for reading, manipulating and writing 
                            # SLHA style input cards. Implementation partly 
                            # inspired by pySLHA (A. Buckley, arXiv:1305.4194).
        --> eHDECAY.py      # Interface with eHDECAY program (arXiv:1403.3381)
        --> relate.py       # Constructs translation paths between bases by 
                            # walking through the translations dictionary in 
                            #Â Rosetta/implemented.py, used by Basis.translate().
        --> query.py        # Yes/no query function borrowed from 
                            # http://code.activestate.com/recipes/577058/.

                                
    --> MassBasis.py        # Basis class for the  default target basis 
                            # for output parameter cards, corresponds to the 
                            # redundant set of operators defined in  
                            # HiggsBasis.py without imposing any dependency 
                            # conditions.
                            
    --> HiggsBasis.py       # Basis class corresponding to the Higgs Basis as 
                            # defined in the HXSWG draft. Using this basis as 
                            # input calculates the dependent coefficients.
                            
    --> WarsawBasis.py      # Basis class corresponding to the Warsaw Basis
                            # defined in arXiv:1008.4884 and the HXSWG draft.
    
    --> SILHBasis.py        # Basis class corresponding to the SILH Basis
                            # defined in e.g arXiv:1303.3876 and the HXSWG draft.
    
    --> TemplateBasis.py    # Template for a user-defined Basis class 
                            # implemented in the Rosetta package. Toy versions 
                            # of the calculate_dependent() and translation
                            # methods are implemented.
                            
    --> implemeted.py       # A file defining a dictionary that logs the set of 
                            # implemented bases and the available translations 
                            # to other bases.

Cards/    # Sample MG5-style parameter cards to be used as input.

    param_card_HiggsBasis.dat       # Sample HiggsBasis input parameter card
    param_card_MassBasis.dat        # Sample MassBasis parameter card, needn't 
                                    # be used as input
    param_card_TemplateBasis.dat    # Sample TemplateBasis input parameter card
    param_card_WarsawBasis.dat      # Sample WarsawBasis input parameter card
    
translate   # Command line tool to perform basis translation based on the
            # implementations in Rosetta.py

################################################################################
3) Usage
################################################################################
The translate command line tool takes an SLHA-style param card (see sample 
cards provided in Cards/ directory) in a particular basis and outputs a new 
card in the specified basis (default is Mass Basis).  

    Command line documentation:
    
    >> usage: translate [-h] [-o OUTPUT] [-t TARGETBASIS] [-w] [-e] PARAMCARD
    >> 
    >> Read in an SLHA format parameter card in a particular basis and write a 
    >> new card in another implemented basis.
    >> 
    >> positional arguments:
    >>   PARAMCARD             Input parameter card.
    >> 
    >> optional arguments:
    >>   -h, --help            show this help message and exit
    >>   -o OUTPUT, --output OUTPUT
    >>                         Output file name. Default: [PARAMCARD]_new
    >>   -t TARGETBASIS, --target TARGETBASIS
    >>                         Basis into which to translate (one of: silh, 
    >>                         higgs, mass, template, warsaw). Default: mass
    >>   -w, --overwrite       Overwrite any pre-existing output file.
    >>   -e, --ehdecay         Interface with eHDECAY for Higgs branching 
    >>                         fractions.

      
################################################################################
4) Input cards
################################################################################
Rosetta is designed to read input cards in a format similar to the SUSY Les 
Houches Accord (SLHA) detailed in http://arxiv.org/abs/hep-ph/0311123. 
Sample cards can be found in the Cards/ directory. 

The SHLA reader looks for block structures in a case insensitive way i.e.

>> BLOCK MYBLOCK

Specifically it will search for blocks MASS, SMINPUTS and BASIS. The basis into 
which the card is read is taken from the 0 entry in the BASIS block. This name 
should match a basis declared in implemented.py (see next section).
Block elements should be named by placing a comment alongside each 
entry. The parameter name will be tken as the first non-whitespace characters 
following the '#' character.

The main difference between the input format of Rosetta and SLHA is that names 
of parameters are required for new physics parameter blocks. Parameters can 
then be referenced by name or number in the corresponding block or, 
alternatively, by name only from the SHLA.Card instance stored in as self.card 
in the basis instance.

>>BLOCK MYBLOCK
>>  0 3.14159E+00 # pi
>>  1 1.97327E-01 # hbarc_GeVfm
>>  Block sminputs 
>>      1   1.325070e+02       #    aEWM1  (white space doesn't matter)
ETC.

The block structure of the new physics couplings is basis dependent and should 
be declared in the `blocks` data member of the basis class. This should be a 
python dictionary with block names as keys and lists of parameter names as 
values. The ordering of the list determines the entry number of each parameter.
For example,

>> blocks = {'ONE':['A','B','C'], 'TWO':['D','E','F']}

will generate the following block structure:

>> block one
>>     0 0.0 # A
>>     1 0.0 # B
>>     2 0.0 # C
>>
>> block two
>>     0 0.0 # D
>>     1 0.0 # E
>>     2 0.0 # F

The reader reads all lines until the next occurrence of 'BLOCK' or 'DECAY', 
ignoring leading and trailing white space and all lines beginning with a '#' as 
well as lines that do not match the expected pattern detailed above. For blocks 
BLOCKIN and SMINPUTS, the reader stores special SLHA.Block instances as 
self.mass and self.inputs data member of the basis instace.

>> block mass 
>>     5 4.700000e+00 # MB 
>>     6 1.730000e+02 # MT 
>>    15 1.730000e+02 # MTAU
>>    23 9.118800e+01 # MZ 
>>    25 1.250000e+02 # MH 

Block basis should have one element corresponding to an existing implementation 
of a basis, defined in implemeted.py.

>> block BASIS
>> 0 MyBasis # name of basis
################################################################################
5) The basis class
################################################################################
Each implemented basis in Rosetta is a python class inheriting from the `Basis` 
class in Rosetta/Internal/Basis.py. 

REWRITE FROM HERE ON
################################################################################
5) Implementing your own basis
################################################################################
Users who wish to implement their own basis should have a minimal understanding 
of implementing formulae and assigning variables in python dictionaries. The 
TemplateBasis.py class illustrates a toy implementation of a basis containing 
the main ingredients necessary.

The base class Basis.py implements a number of reading and writing functions 
designed to remain 'under the hood'.These include reading and writing parameter 
cards, cross checking inputs read in against required inputs, storing the old 
parameter card and writing out a new one with the coefficients of the target 
basis. In general, the only variables needed in a derived class will be the 
following useful data members:

    self.independent        # A list of coefficients required to be defined 
                            # in the input parameter card.

    self.dependent          # A list of dependent coefficients to be assigned 
                            # by the calculate_dependent() function. These 
                            # should not be declared in the input parameter
                            # card.

    self.required_inputs    # A set of required input parameters in block 
                            # SMINPUTS

    self.required_masses    # A set of required article masses in block MASS

    self.par_dict           # dictionary with keys defined by self.independent 
                            # and self.dependent. The parameters in  
                            # self.independent will be read in from the 
                            # input parameter card while those in self.dependent
                            # should be calculated and assigned by the user in 
                            # calculate_dependent().
                            
    self.input              # dictionary with names and values of parameters 
                            # defined in block SMINPUTS.
                            
    self.SHLA_sminputs      # dictionary with SLHA IDs and values of parameters 
                            # defined in block SMINPUTS. Cross checked with 
                            # self.required_inputs
                            
    self.mass               # dictionary with PIDs and particle masses defined 
                            # in block MASS. Cross checked with elements of
                            # self.required_masses

    self.newpar             # dictionary of coefficients to be filled in  
                            # translate() function. The contents of this 
                            # dictionary are written out to the output parameter
                            # card in place of the old basis coefficients of the
                            # input parameter card.

    self.newmass            # dictionary of modified masses to be filled in
                            # translate() function
    self.newinput           # dictionary of modified SM inputs to be filled in
                            # translate() function

The basic steps are as follows:

1)  Create a new file MyBasis.py declaring a class MyBasis inheriting from the 
    Basis class (these names need not coincide). The target basis class can 
    also be imported in order to initialise an empty container to fill in the 
    translate function.
    
    >>from Basis import Basis # base class
    >>from MassBasis import MassBasis # target basis
    >>
    >>class TemplateBasis(Basis):

2)  Minimally, a list of strings called 'independent' should be declared 
    containing the names of the coefficients to be read in the input parameter 
    card and used to calculate the coefficients in the target basis. 
    Additionally, a list named 'dependent' can also optionally be defined 
    containing the names of coefficients to calculate internally before 
    translating to the target basis.
    The set, 'transalte_to' can also be declared to list the existing bases to
    which the implementation provides a translation. The default is {'mass'},
    assuming that the translation is implemented to the mass basis.
    For more consistency, the sets 'required_inputs' and 'required_masses' 
    can also be declared. These tell the basis class to check that the masses 
    of particles with certain PIDs and certain SM input parameters are defined 
    in the blocks MASS and SMINPUTS respectively. If default values exist for 
    these parameters in __init__.py, the user is asked if they wish to continue 
    using those when calling ./translate.
    
    >>class MyBasis(Basis):
    >>    independent = ['a','b','c',...] # list of required parameters
    >>    dependent = ['d','e','f',...]   # list of derived parameters
    >>    required_masses = {1,2,3,4,5,6,...} # PIDs of required particle masses
    >>    required_inputs = {'aEWM1','MZ',...} # required SMINPUT parameters
    >>    translate_to = {'mass','my_other_basis'} # available translations
    
3)  At least the function translate() should be defined that applies the map 
    from the input coefficients to those in the output basis. This can be done 
    by creating and instance of the target basis class and filling its par_dict 
    data member. The function should ultimately assign the dictionary to 
    self.newpar. self.newname can also be assigned.
    The function calculate_dependent() can also be defined which to calculate 
    values of the coefficients declared in 'dependent' and assign them in 
    self.par_dict.The dictionary self.newmass can also be modified at any 
    stage if modifications to particle masses occur. This should be a 
    dictionary of PID:mass pairs that will replace the entries in self.mass.
    
    >>    def calculate_dependent(self):
    >>        '''
    >>        Calculate dependent parameters here by assigning values 
    >>        to self.par_dict corresponding to the keys in self.dependent.
    >>        '''
    >>        p = self.par_dict
    >>        p['d'] = p['a']+ p['b']*p['c'] # set a value for 'd' coefficient
    >>
    >>    def translate(self):
    >>        '''
    >>        Translate to the mass basis by creating an empty MassBasis 
    >>        and modifying its par_dict or coeffs._asdict().
    >>        Set self.newpar with resulting dictionary
    >>        '''
    >>        A = self.coeffs._asdict()
    >>        # initialise empty par_dict of the target basis instance
    >>        B = MassBasis().coeffs._asdict() 
    >>        # set all values of coeffs according to nonsense formula: 
    >>        # C = coeff_d * m_top / a_EW
    >>        for k in B.keys(): 
    >>            B[k]=A['d']*self.mass[6]/self.input['aEWM1']
    >>        self.newpar = B
    >>        self.newname = 'Mass'

4)  Once the translate() function has been defined, the implementation is 
    complete and can be tested with the translate tool. The new basis should be 
    added to the dictionary 'bases' in implemented.py in order to make the tool 
    aware of its existence. This is done by importing the new module and 
    appending it to the dictionary.
    
    In implemented.py:
    
    >> import WarsawBasis, HiggsBasis, MassBasis, TemplateBasis
    >> import MyBasis
    
    >> bases['mybasis'] = MyBasis.MyBasis
    
    The options for ./translate -h should now include "mybasis" as a possible
    BASIS argument.
    
################################################################################
6) eHDECAY interface
################################################################################
A useful program based on HDECAY (arXiv:hep-ph/9704448) for calculating the 
Higgs total width was developed in 2014 and is described in arXiv:1403.3381. 
The program takes as input a number of parameters in the SILH basis to calculate
the width and branching ratios to SM particles optionally including Electroweak 
corrections. In order to have this working correctly the user must:

1)  Modify the variable eHDECAY_dir in __init__.py to have it pointing to the 
    location of your installation of eHDECAY
    
    In __init__.py:
    
    >> eHDECAY_dir = '/PATH/TO/eHDECAY'

2)  Define the member function eHDECAY_inputs() in their basis implementation.

    In MyBasis.py:
    
    >> def eHDECAY_inputs(self):
    >>     inputs = dict() # populate with values for inputs defined below
    >>     ..
    >>     ..
    >>     return inputs

    Currently, the translations to and from SILH basis have not yet been implemented
    and so the user will be required to provide the necessary inputs via the 
    definition of the eHDECAY_inputs() function. The required SM and SILH basis 
    inputs are listed in eHDECAY.py and are as follows:

    SM inputs: # ALL masses must be nonzero for eHDECAY to give a finite result
    'MC', 'MB', 'MT', 'MMU', 'MTAU, # SM fermion masses
    'MH', 'MZ', 'MW', 'aEWM1' 'Gf', # EW input masses, (alpha_EW)^-1, G_Fermi
    'aSMZ'                          # alpha_S(MZ)

    SILH coefficients:
    'CHbar' , 'CTbar' , 'Ctaubar', 'Cmubar', 'Ctbar',
    'Cbbar' , 'Ccbar' , 'Csbar'  , 'CWbar' , 'CBbar',
    'CHWbar', 'CHBbar', 'Cgambar', 'Cgbar'

    eHDECAY option:
    'IELW' # Electroweak corrections switch (1:on, 0:off)

An example of a toy implementation is given in TemplateBasis.py which uses the 
default values for the SM inputs and sets the SILH coefficients. 
eHDECAY_inputs() should return a dictionary of name:value pairs for the 
parameters listed above.

Rosetta will take the inputs and run eHDECAY in a temporary directory and read
the relevant branching ratios, updating or creating the DECAY block in the 
output card. 

################################################################################
Rosetta: A Higgs Effective Field Theory basis translator
################################################################################






